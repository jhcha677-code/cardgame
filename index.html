<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Classic FreeCell</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        /* Body fixed to viewport to prevent scroll bounce & refresh */
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background-color: #166534; /* Green-800 fallback */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        /* Card Styles */
        .card {
            width: 90%; 
            left: 5%;
            aspect-ratio: 5 / 7; 
            background-color: white;
            border-radius: 0.3rem;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: absolute;
            transition: transform 0.2s, box-shadow 0.2s, top 0.2s ease; /* Added transition for smooth spacing adjustment */
            cursor: pointer;
            border: 0; 
            touch-action: none; 
        }
        
        .card.selected {
            box-shadow: 0 0 0 3px #fbbf24, 0 4px 6px rgba(0,0,0,0.4);
            transform: translateY(-5px);
            z-index: 100 !important;
        }

        /* Areas */
        .placeholder {
            position: relative;
            width: 90%;
            aspect-ratio: 5 / 7;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 0.3rem;
            background-color: rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Toast Message */
        #toast-container {
            pointer-events: none;
            z-index: 100; 
        }
        .toast {
            background-color: rgba(0,0,0,0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 999px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.95rem;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .toast.show {
            opacity: 1;
        }

        /* Landscape Enforcement */
        #rotate-message { display: none; }
        @media only screen and (max-width: 768px) and (orientation: portrait) {
            #app-container { display: none; }
            #rotate-message { display: flex; }
        }

        /* Floating Animation */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }
    </style>
    <script>
        // Global prevention of native scroll/zoom
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</head>
<body class="bg-green-800 text-white">

    <!-- Portrait Mode Warning -->
    <div id="rotate-message" class="fixed inset-0 z-50 bg-green-900 flex flex-col items-center justify-center text-center p-6">
        <i data-lucide="smartphone" class="w-16 h-16 mb-4 animate-float text-yellow-400"></i>
        <h2 class="text-2xl font-bold mb-2">가로 모드로 돌려주세요</h2>
        <p class="text-green-200">원활한 게임 플레이를 위해 화면을 회전해주세요.</p>
    </div>

    <!-- Toast Notification -->
    <div id="toast-container" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center w-full px-4"></div>

    <!-- Main App Container -->
    <div id="app-container" class="w-full h-full relative flex flex-col">
        
        <!-- Header / HUD -->
        <div class="h-10 md:h-12 bg-green-900 flex items-center justify-between px-3 shadow-md z-20 shrink-0">
            <div class="flex items-center space-x-3">
                <span class="font-bold text-yellow-400 text-base md:text-lg">FreeCell</span>
                <div class="text-xs md:text-sm text-green-200 flex space-x-2">
                    <span id="score-display">점수: 0</span>
                    <span id="timer-display">시간: 00:00</span>
                </div>
            </div>
            <div class="flex items-center space-x-1">
                <span id="user-display" class="text-xs md:text-sm font-semibold mr-2 text-white/80"></span>
                <button id="btn-restart" class="p-1.5 md:p-2 hover:bg-green-700 rounded text-white" title="다시 시작">
                    <i data-lucide="rotate-ccw" class="w-4 h-4 md:w-5 md:h-5"></i>
                </button>
                <button id="btn-exit" class="p-1.5 md:p-2 hover:bg-red-700 rounded text-white bg-red-800/50" title="나가기">
                    <i data-lucide="log-out" class="w-4 h-4 md:w-5 md:h-5"></i>
                </button>
            </div>
        </div>

        <!-- Start Screen / Leaderboard -->
        <div id="start-screen" class="absolute inset-0 z-40 bg-green-800/95 backdrop-blur-sm flex items-center justify-center">
            <div class="bg-white text-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full mx-4 border-4 border-green-600 animate-float">
                <div class="text-center mb-6">
                    <h1 class="text-4xl font-bold text-green-700 mb-2">FreeCell</h1>
                    <p class="text-gray-500">클래식 프리셀 카드게임</p>
                </div>
                
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-1">닉네임</label>
                    <input type="text" id="nickname-input" class="w-full px-4 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-green-500 outline-none" placeholder="닉네임을 입력하세요" maxlength="10">
                    <p id="nickname-error" class="text-red-500 text-xs mt-1 hidden">닉네임을 입력해주세요.</p>
                </div>

                <button id="btn-play" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg shadow-lg transition transform active:scale-95 mb-6 text-lg">
                    게임 시작
                </button>

                <div class="border-t border-gray-200 pt-4">
                    <h3 class="text-lg font-bold text-gray-700 mb-3 flex items-center">
                        <i data-lucide="trophy" class="w-5 h-5 mr-2 text-yellow-500"></i> 명예의 전당
                    </h3>
                    <div class="bg-gray-50 rounded h-48 overflow-y-auto custom-scrollbar p-2">
                        <table class="w-full text-sm">
                            <thead class="text-gray-500 border-b">
                                <tr>
                                    <th class="text-left py-1">순위</th>
                                    <th class="text-left py-1">이름</th>
                                    <th class="text-right py-1">시간</th>
                                </tr>
                            </thead>
                            <tbody id="leaderboard-list">
                                <tr><td colspan="3" class="text-center py-4 text-gray-400">로딩 중...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen" class="hidden absolute inset-0 z-50 bg-black/80 flex items-center justify-center">
            <div class="text-center text-white p-8 animate-float bg-gray-900/90 rounded-2xl mx-4 max-w-sm w-full">
                <h1 class="text-5xl font-bold text-yellow-400 mb-4">승리!</h1>
                <p class="text-xl mb-2">축하합니다!</p>
                <div class="text-lg mb-4 text-gray-300">
                    <p>최종 점수: <span id="final-score" class="text-white font-bold">0</span></p>
                    <p>소요 시간: <span id="final-time" class="text-white font-bold">00:00</span></p>
                </div>
                
                <!-- Save Status & Retry -->
                <div id="save-status" class="text-sm min-h-[1.5rem] mb-4 font-semibold text-yellow-300"></div>
                <button id="btn-retry-save" class="hidden w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded-lg mb-3 transition">
                    저장 다시 시도
                </button>

                <button id="btn-victory-home" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition">
                    메인으로 돌아가기
                </button>
            </div>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="flex-1 p-2 md:p-4 flex flex-col max-w-7xl mx-auto w-full h-full pb- safe-bottom">
            
            <!-- Top Row: Freecells (Left) & Foundations (Right) -->
            <div class="flex justify-between h-[25%] mb-2 shrink-0">
                <!-- Freecells (4) -->
                <div class="flex gap-1.5 w-[48%]">
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-0" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-1" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-2" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-3" class="placeholder"></div></div>
                </div>

                <!-- Spacer -->
                <div class="w-[4%]"></div>

                <!-- Foundations (4) -->
                <div class="flex gap-1.5 w-[48%]">
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-0" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-1" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-2" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-3" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                </div>
            </div>

            <!-- Bottom Row: Tableaus (8) -->
            <div class="flex-1 flex gap-1 w-full h-full overflow-hidden relative" id="tableau-area">
                <div id="tableau-0" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-1" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-2" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-3" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-4" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-5" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-6" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-7" class="w-[12.5%] relative h-full"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const userConfig = {
            apiKey: "AIzaSyABtG2uYP6iXpXOphVPTY_roUbHMzBDGek",
            authDomain: "cardgame-8bae4.firebaseapp.com",
            projectId: "cardgame-8bae4",
            storageBucket: "cardgame-8bae4.firebasestorage.app",
            messagingSenderId: "931605513570",
            appId: "1:931605513570:web:8f58953994bda3fdcad83b"
        };
        
        // 중요: appId를 고정된 값으로 변경하여 항상 같은 컬렉션을 바라보게 함
        // 기존에는 환경변수나 default-app을 사용했는데, 접속마다 바뀔 수 있어 데이터가 유실된 것처럼 보임
        const appId = 'freecell_rank_v1';
        
        // Use user config explicitly
        const firebaseConfig = userConfig;
        
        let db, auth, user;

        try {
            console.log("Initializing Firebase...");
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            const initAuth = async () => {
                let signedIn = false;
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try {
                        await signInWithCustomToken(auth, __initial_auth_token);
                        signedIn = true;
                        console.log("Signed in with custom token");
                    } catch (e) {
                        console.warn("Custom token auth skipped/failed:", e.code);
                    }
                }

                if (!signedIn) {
                    try {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously");
                    } catch (e) {
                        console.error("Anonymous auth failed:", e);
                        if (window.showToast) window.showToast("인증 서버 연결 실패: 콘솔 설정을 확인하세요.");
                    }
                }
            };
            initAuth();

            onAuthStateChanged(auth, (u) => {
                user = u;
                if(user) {
                    console.log("Firebase Connected. UID:", user.uid);
                    loadLeaderboard();
                } else {
                    console.log("User signed out");
                }
            });
        } catch (e) {
            console.error("Firebase init failed:", e);
            const listEl = document.querySelector("#leaderboard-list");
            if(listEl) listEl.innerHTML = '<tr><td colspan="3" class="text-center py-4">서비스 연결 불가</td></tr>';
        }

        function loadLeaderboard() {
            if (!db) return;
            const colRef = collection(db, 'artifacts', appId, 'public', 'data', 'freecell_scores');
            
            onSnapshot(colRef, (snapshot) => {
                const scores = [];
                snapshot.forEach(doc => scores.push(doc.data()));
                
                scores.sort((a, b) => {
                    const getSeconds = (item) => {
                        if (typeof item.duration === 'number') return item.duration;
                        if (typeof item.time === 'string') {
                            const parts = item.time.split(':');
                            if (parts.length === 2) return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                        }
                        return 999999;
                    };
                    return getSeconds(a) - getSeconds(b);
                }); 
                
                const top10 = scores.slice(0, 10);
                const tbody = document.getElementById('leaderboard-list');
                if (tbody) {
                    tbody.innerHTML = '';

                    // Load cached nickname if current one is empty (initial load)
                    const currentName = nickname || localStorage.getItem('freecell_nickname');

                    top10.forEach((s, idx) => {
                        // Highlight if matches current user nickname
                        const isMe = currentName && s.nickname === currentName;
                        const rowClass = isMe ? "bg-yellow-100 font-bold border-b border-yellow-200 text-yellow-900" : "border-b border-gray-100 last:border-0 hover:bg-gray-100";
                        
                        const row = `
                            <tr class="${rowClass}">
                                <td class="py-2 pl-2 text-gray-500 font-mono">${idx + 1}</td>
                                <td class="py-2 font-medium text-gray-800 truncate max-w-[100px]">${s.nickname}</td>
                                <td class="py-2 text-right pr-2 font-bold ${isMe ? 'text-yellow-700' : 'text-green-700'}">${s.time}</td>
                            </tr>
                        `;
                        tbody.innerHTML += row;
                    });

                    if (scores.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-400">기록이 없습니다.</td></tr>';
                    }
                }
            }, (error) => {
                console.error("Leaderboard error:", error);
            });
        }

        async function saveScore(nickname, score, timeStr, duration) {
            console.log("Saving score:", { nickname, score, timeStr, duration });
            
            if (!db) {
                return { success: false, message: "데이터베이스 연결 실패" };
            }

            if (!auth.currentUser) {
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    console.error("Auth retry failed:", e);
                    return { success: false, message: "인증 실패: 다시 시도해주세요." };
                }
            }

            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'freecell_scores'), {
                    nickname: nickname,
                    score: score,
                    time: timeStr,
                    duration: duration,
                    uid: auth.currentUser.uid,
                    createdAt: serverTimestamp()
                });
                console.log("Score saved successfully!");
                return { success: true };
            } catch (e) {
                console.error("Save score failed:", e);
                return { success: false, message: "저장 오류: " + e.message };
            }
        }
        window.saveGameScore = saveScore;
    </script>

    <script>
        const SUITS = ['♠', '♥', '♣', '♦'];
        const COLORS = { '♠': 'black', '♣': 'black', '♥': 'red', '♦': 'red' };
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        
        let gameState = {
            tableaus: [[], [], [], [], [], [], [], []],
            freecells: [null, null, null, null],
            foundations: [[], [], [], []],
            score: 0,
            startTime: 0,
            timerInterval: null
        };

        let selectedCard = null; 
        let nickname = "";
        let autoMoveTimeout = null;

        // Toast functionality
        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast show';
            toast.innerText = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }
        
        window.showToast = showToast;

        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            document.getElementById('btn-play').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', restartGame);
            document.getElementById('btn-exit').addEventListener('click', exitGame);
            document.getElementById('btn-victory-home').addEventListener('click', exitGame);
            document.getElementById('btn-retry-save').addEventListener('click', retrySaveScore);
            
            const savedName = localStorage.getItem('freecell_nickname');
            if (savedName) {
                const inputEl = document.getElementById('nickname-input');
                if (inputEl) inputEl.value = savedName;
                nickname = savedName; 
            }

            bindGameEvents();
            window.addEventListener('resize', resizeCards);
        });

        function bindGameEvents() {
            for (let i = 0; i < 4; i++) {
                addTouchAndClickHandlers(document.getElementById(`freecell-${i}`), 'freecell', i);
                addTouchAndClickHandlers(document.getElementById(`foundation-${i}`), 'foundation', i);
            }
            for (let i = 0; i < 8; i++) {
                addTouchAndClickHandlers(document.getElementById(`tableau-${i}`), 'tableau', i);
            }
        }

        function addTouchAndClickHandlers(element, type, index) {
            let lastTap = 0;
            let startX, startY;

            element.addEventListener('click', (e) => handlePlaceClick(type, index, e));
            element.addEventListener('dblclick', (e) => handleDoubleClick(type, index));
            
            element.addEventListener('touchstart', (e) => {
                startX = e.changedTouches[0].clientX;
                startY = e.changedTouches[0].clientY;
            }, { passive: false });

            element.addEventListener('touchend', (e) => {
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                
                if (Math.abs(endX - startX) < 10 && Math.abs(endY - startY) < 10) {
                    e.preventDefault();
                    const currentTime = new Date().getTime();
                    if (currentTime - lastTap < 300) {
                        handleDoubleClick(type, index);
                    } else {
                        handlePlaceClick(type, index, e);
                    }
                    lastTap = currentTime;
                }
            }, { passive: false });
        }

        // --- NEW: Dynamic Card Spacing Calculation ---
        function calculateTableauOffset() {
            const tableauArea = document.getElementById('tableau-area');
            const boardHeight = tableauArea.clientHeight;
            
            // Standard spacing we want
            const standardOffset = 26; // Reduced from 35 to fit more
            
            // Card height is implicitly defined by width/aspect-ratio.
            // We need to approximate it to prevent overflow.
            // Width is 12.5% of board width * 0.9.
            // Aspect ratio 5/7 means Height = Width * 1.4.
            const colWidth = tableauArea.clientWidth / 8;
            const cardWidth = colWidth * 0.9;
            const cardHeight = cardWidth * 1.4;

            // Find the maximum number of cards in any column
            let maxCards = 0;
            gameState.tableaus.forEach(col => {
                if (col.length > maxCards) maxCards = col.length;
            });

            // Calculate height required with standard offset
            const requiredHeight = (maxCards - 1) * standardOffset + cardHeight;

            // If it doesn't fit, shrink offset
            if (requiredHeight > boardHeight && maxCards > 1) {
                // formula: (maxCards - 1) * offset + cardHeight = boardHeight
                // offset = (boardHeight - cardHeight) / (maxCards - 1)
                // Add a small buffer (-10px) to not touch edge perfectly
                let compressedOffset = (boardHeight - cardHeight - 10) / (maxCards - 1);
                return Math.max(compressedOffset, 8); // Minimum visible offset (e.g. 8px)
            }

            return standardOffset;
        }

        function resizeCards() { updateUI(); }

        function startGame() {
            const input = document.getElementById('nickname-input');
            const errorMsg = document.getElementById('nickname-error');
            if (!input.value.trim()) {
                errorMsg.classList.remove('hidden');
                input.focus();
                return;
            }
            errorMsg.classList.add('hidden');
            nickname = input.value.trim();
            localStorage.setItem('freecell_nickname', nickname);
            document.getElementById('user-display').innerText = nickname;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
            initGame();
        }

        function initGame() {
            gameState.tableaus = [[], [], [], [], [], [], [], []];
            gameState.freecells = [null, null, null, null];
            gameState.foundations = [[], [], [], []];
            gameState.score = 0;
            gameState.startTime = Date.now();
            selectedCard = null;
            if (autoMoveTimeout) clearTimeout(autoMoveTimeout);

            let deck = [];
            SUITS.forEach(suit => {
                RANKS.forEach((rank, index) => {
                    deck.push({ suit, rank, value: index + 1, color: COLORS[suit], id: `${rank}${suit}` });
                });
            });
            
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }

            deck.forEach((card, i) => {
                gameState.tableaus[i % 8].push(card);
            });

            startTimer();
            updateUI();
        }

        function restartGame() { initGame(); }

        function exitGame() {
            stopTimer();
            if (autoMoveTimeout) clearTimeout(autoMoveTimeout);
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
        }

        function createCardHTML(card, isSelected = false) {
            if (!card) return '';
            const suitCode = {'♠':'S', '♥':'H', '♣':'C', '♦':'D'}[card.suit];
            const rankCode = (card.rank === '10') ? '0' : card.rank;
            const imgUrl = `https://deckofcardsapi.com/static/img/${rankCode}${suitCode}.png`;
            const selectedClass = isSelected ? 'selected' : '';
            return `
                <div class="card ${selectedClass}" id="${card.id}">
                    <img src="${imgUrl}" 
                         class="w-full h-full object-cover rounded-sm pointer-events-none select-none" 
                         alt="${card.rank}${card.suit}"
                         onerror="this.style.display='none'; this.parentElement.classList.add('fallback-card');">
                </div>
            `;
        }

        function updateUI() {
            gameState.freecells.forEach((card, i) => {
                const el = document.getElementById(`freecell-${i}`);
                el.innerHTML = '';
                if (card) {
                    const isSel = selectedCard && selectedCard.type === 'freecell' && selectedCard.index === i;
                    el.innerHTML = createCardHTML(card, isSel);
                }
            });

            gameState.foundations.forEach((pile, i) => {
                const el = document.getElementById(`foundation-${i}`);
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    el.innerHTML = createCardHTML(topCard, false);
                    el.classList.remove('text-white/20', 'text-xl');
                } else {
                    el.innerHTML = 'A';
                    el.classList.add('text-white/20', 'text-xl');
                }
            });

            // Use dynamic offset calculation for responsiveness
            const offset = calculateTableauOffset();
            
            gameState.tableaus.forEach((col, i) => {
                const el = document.getElementById(`tableau-${i}`);
                el.innerHTML = ''; 
                
                col.forEach((card, cardIndex) => {
                    const cardDiv = document.createElement('div');
                    let isSel = false;
                    if (selectedCard && selectedCard.type === 'tableau' && selectedCard.index === i) {
                        if (cardIndex >= selectedCard.originIndex) isSel = true;
                    }
                    
                    cardDiv.innerHTML = createCardHTML(card, isSel);
                    const cardInner = cardDiv.firstElementChild;
                    
                    cardInner.style.top = `${cardIndex * offset}px`; 
                    cardInner.style.zIndex = cardIndex;
                    cardInner.dataset.index = cardIndex;
                    
                    el.appendChild(cardInner);
                });
            });

            document.getElementById('score-display').innerText = `점수: ${gameState.score}`;
            checkWin();
        }

        window.handlePlaceClick = (type, index, event) => {
            let cardIndex = -1;
            if (event && (event.type === 'click' || event.type === 'touchend')) {
                let target = event.target;
                if (event.changedTouches) {
                    target = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
                }
                const cardEl = target ? target.closest('.card') : null;
                if (cardEl && cardEl.dataset.index !== undefined) {
                    cardIndex = parseInt(cardEl.dataset.index);
                }
            }

            if (!selectedCard) {
                selectSource(type, index, cardIndex);
            } 
            else if (selectedCard.type === type && selectedCard.index === index) {
                let cardToMove = null;
                if (type === 'freecell') {
                    cardToMove = gameState.freecells[index];
                } else if (type === 'tableau') {
                    if (selectedCard.cards.length === 1) {
                        const col = gameState.tableaus[index];
                        if (col.length > 0) cardToMove = col[col.length - 1];
                    }
                }

                if (cardToMove && moveCardToFoundation(cardToMove, type, index)) {
                    selectedCard = null;
                    updateUI();
                    if (autoMoveTimeout) clearTimeout(autoMoveTimeout);
                    autoMoveTimeout = setTimeout(checkAutoMoves, 200);
                    return;
                }

                selectedCard = null;
                updateUI();
            }
            else {
                attemptMove(type, index);
            }
        };

        window.handleDoubleClick = (type, index) => {
            let card = null;
            if (type === 'freecell') {
                card = gameState.freecells[index];
            } else if (type === 'tableau') {
                const col = gameState.tableaus[index];
                if (col.length > 0) card = col[col.length - 1];
            }

            if (!card) return;

            if (moveCardToFoundation(card, type, index)) {
                selectedCard = null;
                updateUI();
                if (autoMoveTimeout) clearTimeout(autoMoveTimeout);
                autoMoveTimeout = setTimeout(checkAutoMoves, 200);
            }
        };

        function moveCardToFoundation(card, sourceType, sourceIndex) {
            for (let fIdx = 0; fIdx < 4; fIdx++) {
                const pile = gameState.foundations[fIdx];
                let canMove = false;
                
                if (pile.length === 0) {
                    if (card.value === 1) canMove = true;
                } else {
                    const top = pile[pile.length - 1];
                    if (top.suit === card.suit && card.value === top.value + 1) canMove = true;
                }

                if (canMove) {
                    if (sourceType === 'freecell') gameState.freecells[sourceIndex] = null;
                    else gameState.tableaus[sourceIndex].pop();
                    
                    pile.push(card);
                    gameState.score += 10;
                    return true;
                }
            }
            return false;
        }

        function selectSource(type, index, clickedIndex = -1) {
            if (type === 'freecell') {
                const card = gameState.freecells[index];
                if (card) selectedCard = { type, index, cards: [card], originIndex: 0 };
            } else if (type === 'tableau') {
                const col = gameState.tableaus[index];
                if (col.length > 0) {
                    let validStartIdx = col.length - 1;
                    for (let i = col.length - 2; i >= 0; i--) {
                        const current = col[i];
                        const next = col[i+1];
                        const isDiffColor = current.color !== next.color;
                        const isRankAbove = current.value === next.value + 1;
                        if (isDiffColor && isRankAbove) {
                            validStartIdx = i;
                        } else {
                            break; 
                        }
                    }

                    let selectFrom = validStartIdx;
                    if (clickedIndex !== -1) {
                        if (clickedIndex >= validStartIdx) {
                            selectFrom = clickedIndex; 
                        } 
                    }

                    const stack = col.slice(selectFrom);
                    selectedCard = { type, index, cards: stack, originIndex: selectFrom };
                }
            }
            if (selectedCard) updateUI();
        }

        function getAvailableMoves() {
            const emptyFreecells = gameState.freecells.filter(c => c === null).length;
            const emptyTableaus = gameState.tableaus.filter(c => c.length === 0).length;
            return { emptyFreecells, emptyTableaus };
        }

        function attemptMove(destType, destIndex) {
            if (!selectedCard) return;

            let success = false;
            let movePoints = 0;
            const movingCards = selectedCard.cards;
            
            if (destType === 'freecell') {
                if (movingCards.length === 1 && gameState.freecells[destIndex] === null) {
                    removeFromSource(1);
                    gameState.freecells[destIndex] = movingCards[0];
                    success = true;
                }
            } 
            else if (destType === 'foundation') {
                if (movingCards.length === 1) {
                    if (moveCardToFoundation(movingCards[0], selectedCard.type, selectedCard.index)) {
                        success = true;
                        selectedCard = null;
                        updateUI();
                        if (autoMoveTimeout) clearTimeout(autoMoveTimeout);
                        autoMoveTimeout = setTimeout(checkAutoMoves, 200);
                        return;
                    }
                }
            } 
            else if (destType === 'tableau') {
                const col = gameState.tableaus[destIndex];
                const { emptyFreecells, emptyTableaus } = getAvailableMoves();
                
                let effectiveEmptyCols = emptyTableaus;
                if (col.length === 0) effectiveEmptyCols = Math.max(0, emptyTableaus - 1);
                
                const maxCards = (emptyFreecells + 1) * Math.pow(2, effectiveEmptyCols);

                if (movingCards.length <= maxCards) {
                    if (col.length === 0) {
                        removeFromSource(movingCards.length);
                        movingCards.forEach(c => col.push(c));
                        success = true;
                    } else {
                        const destCard = col[col.length - 1];
                        const bottomMoving = movingCards[0]; 
                        
                        if (bottomMoving.color !== destCard.color && bottomMoving.value === destCard.value - 1) {
                            removeFromSource(movingCards.length);
                            movingCards.forEach(c => col.push(c));
                            success = true;
                        }
                    }
                } else {
                    showToast(`이동 가능한 카드 수(${maxCards}장)를 초과했습니다.`);
                }
            }

            if (success) {
                gameState.score += movePoints;
                selectedCard = null;
                updateUI();
                if (autoMoveTimeout) clearTimeout(autoMoveTimeout);
                autoMoveTimeout = setTimeout(checkAutoMoves, 200);
            } else {
                selectedCard = null;
                updateUI();
            }
        }

        function removeFromSource(count) {
            if (selectedCard.type === 'freecell') {
                gameState.freecells[selectedCard.index] = null;
            } else if (selectedCard.type === 'tableau') {
                for(let i=0; i<count; i++) {
                    gameState.tableaus[selectedCard.index].pop();
                }
            }
        }

        function checkAutoMoves() {
            let moved = false;
            
            let minBlack = 14, minRed = 14;
            let blackRanks = [], redRanks = [];
            gameState.foundations.forEach(pile => {
                if (pile.length > 0) {
                    const top = pile[pile.length - 1];
                    if (top.color === 'black') blackRanks.push(top.value);
                    else redRanks.push(top.value);
                }
            });
            while (blackRanks.length < 2) blackRanks.push(0);
            while (redRanks.length < 2) redRanks.push(0);
            
            const limits = { 
                minBlack: Math.min(...blackRanks), 
                minRed: Math.min(...redRanks) 
            };

            for (let i = 0; i < 4; i++) {
                if (gameState.freecells[i]) {
                    if (tryAutoMove(gameState.freecells[i], 'freecell', i, limits)) {
                        moved = true;
                        break; 
                    }
                }
            }

            if (!moved) {
                for (let i = 0; i < 8; i++) {
                    const col = gameState.tableaus[i];
                    if (col.length > 0) {
                        const card = col[col.length - 1];
                        if (tryAutoMove(card, 'tableau', i, limits)) {
                            moved = true;
                            break;
                        }
                    }
                }
            }

            if (moved) {
                updateUI();
                autoMoveToFoundation = setTimeout(checkAutoMoves, 150); 
            }
        }

        function tryAutoMove(card, sourceType, sourceIndex, limits) {
            let isSafe = false;
            if (card.value <= 2) isSafe = true; 
            else {
                if (card.color === 'red') {
                    if (limits.minBlack >= card.value - 1) isSafe = true;
                } else {
                    if (limits.minRed >= card.value - 1) isSafe = true;
                }
            }

            if (!isSafe) return false;
            return moveCardToFoundation(card, sourceType, sourceIndex);
        }

        function checkWin() {
            const total = gameState.foundations.reduce((acc, pile) => acc + pile.length, 0);
            if (total === 52) endGame();
        }

        async function endGame() {
            stopTimer();
            const timeStr = document.getElementById('timer-display').innerText.replace('시간: ', '');
            document.getElementById('final-score').innerText = gameState.score;
            document.getElementById('final-time').innerText = timeStr;
            document.getElementById('victory-screen').classList.remove('hidden');
            
            // Hide retry button initially
            document.getElementById('btn-retry-save').classList.add('hidden');
            document.getElementById('save-status').innerText = "기록 저장 중...";
            document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-semibold text-yellow-300";

            if (window.saveGameScore && nickname) {
                // Calculate duration in seconds for accurate sorting
                const timeParts = timeStr.split(':');
                const duration = parseInt(timeParts[0]) * 60 + parseInt(timeParts[1]);

                const result = await window.saveGameScore(nickname, gameState.score, timeStr, duration);
                
                if (result && result.success) {
                    document.getElementById('save-status').innerText = "기록 저장 완료!";
                    document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-bold text-green-400";
                } else {
                    document.getElementById('save-status').innerText = result?.message || "저장 실패";
                    document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-bold text-red-400";
                    document.getElementById('btn-retry-save').classList.remove('hidden');
                }
            } else {
                document.getElementById('save-status').innerText = "저장 불가 (닉네임 없음)";
            }
        }

        async function retrySaveScore() {
            const timeStr = document.getElementById('final-time').innerText;
            document.getElementById('btn-retry-save').classList.add('hidden');
            document.getElementById('save-status').innerText = "저장 재시도 중...";
            document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-semibold text-yellow-300";
            
            if (window.saveGameScore && nickname) {
                const timeParts = timeStr.split(':');
                const duration = parseInt(timeParts[0]) * 60 + parseInt(timeParts[1]);

                const result = await window.saveGameScore(nickname, gameState.score, timeStr, duration);
                if (result && result.success) {
                    document.getElementById('save-status').innerText = "기록 저장 완료!";
                    document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-bold text-green-400";
                } else {
                    document.getElementById('save-status').innerText = result?.message || "저장 실패";
                    document.getElementById('save-status').className = "text-sm min-h-[1.5rem] mb-4 font-bold text-red-400";
                    document.getElementById('btn-retry-save').classList.remove('hidden');
                }
            }
        }

        function startTimer() {
            stopTimer();
            const start = Date.now();
            gameState.timerInterval = setInterval(() => {
                const delta = Math.floor((Date.now() - start) / 1000);
                const m = Math.floor(delta / 60).toString().padStart(2, '0');
                const s = (delta % 60).toString().padStart(2, '0');
                document.getElementById('timer-display').innerText = `시간: ${m}:${s}`;
            }, 1000);
        }

        function stopTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        }
    </script>
</body>
</html>