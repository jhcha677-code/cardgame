<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Classic FreeCell</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        /* Body fixed to viewport to prevent scroll bounce & refresh */
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background-color: #166534; /* Green-800 fallback */
        }
        
        /* Card Styles */
        .card {
            width: 70%; 
            left: 15%; /* Center in column */
            aspect-ratio: 5 / 7; 
            background-color: white;
            border-radius: 0.3rem;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: absolute;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            border: 0; 
            touch-action: none; /* Crucial for touch handling */
        }
        
        .card.selected {
            box-shadow: 0 0 0 3px #fbbf24, 0 4px 6px rgba(0,0,0,0.4);
            transform: translateY(-5px);
            z-index: 100 !important;
        }

        /* Areas */
        .placeholder {
            position: relative;
            width: 70%;
            aspect-ratio: 5 / 7;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 0.3rem;
            background-color: rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Toast Message */
        #toast-container {
            pointer-events: none;
        }
        .toast {
            background-color: rgba(0,0,0,0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 999px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.95rem;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .toast.show {
            opacity: 1;
        }

        /* Landscape Enforcement */
        #rotate-message { display: none; }
        @media only screen and (max-width: 768px) and (orientation: portrait) {
            #app-container { display: none; }
            #rotate-message { display: flex; }
        }

        /* Floating Animation */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }
    </style>
    <script>
        // Global prevention of native scroll/zoom
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</head>
<body class="bg-green-800 text-white">

    <!-- Portrait Mode Warning -->
    <div id="rotate-message" class="fixed inset-0 z-50 bg-green-900 flex flex-col items-center justify-center text-center p-6">
        <i data-lucide="smartphone" class="w-16 h-16 mb-4 animate-float text-yellow-400"></i>
        <h2 class="text-2xl font-bold mb-2">가로 모드로 돌려주세요</h2>
        <p class="text-green-200">원활한 게임 플레이를 위해 화면을 회전해주세요.</p>
    </div>

    <!-- Toast Notification -->
    <div id="toast-container" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 flex flex-col items-center w-full px-4"></div>

    <!-- Main App Container -->
    <div id="app-container" class="w-full h-full relative flex flex-col">
        
        <!-- Header / HUD -->
        <div class="h-10 md:h-12 bg-green-900 flex items-center justify-between px-3 shadow-md z-20 shrink-0">
            <div class="flex items-center space-x-3">
                <span class="font-bold text-yellow-400 text-base md:text-lg">FreeCell</span>
                <div class="text-xs md:text-sm text-green-200 flex space-x-2">
                    <span id="score-display">점수: 0</span>
                    <span id="timer-display">시간: 00:00</span>
                </div>
            </div>
            <div class="flex items-center space-x-1">
                <span id="user-display" class="text-xs md:text-sm font-semibold mr-2 text-white/80"></span>
                <button id="btn-restart" class="p-1.5 md:p-2 hover:bg-green-700 rounded text-white" title="다시 시작">
                    <i data-lucide="rotate-ccw" class="w-4 h-4 md:w-5 md:h-5"></i>
                </button>
                <button id="btn-exit" class="p-1.5 md:p-2 hover:bg-red-700 rounded text-white bg-red-800/50" title="나가기">
                    <i data-lucide="log-out" class="w-4 h-4 md:w-5 md:h-5"></i>
                </button>
            </div>
        </div>

        <!-- Start Screen / Leaderboard -->
        <div id="start-screen" class="absolute inset-0 z-40 bg-green-800/95 backdrop-blur-sm flex items-center justify-center">
            <div class="bg-white text-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full mx-4 border-4 border-green-600 animate-float">
                <div class="text-center mb-6">
                    <h1 class="text-4xl font-bold text-green-700 mb-2">FreeCell</h1>
                    <p class="text-gray-500">클래식 프리셀 카드게임</p>
                </div>
                
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-1">닉네임</label>
                    <input type="text" id="nickname-input" class="w-full px-4 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-green-500 outline-none" placeholder="닉네임을 입력하세요" maxlength="10">
                    <p id="nickname-error" class="text-red-500 text-xs mt-1 hidden">닉네임을 입력해주세요.</p>
                </div>

                <button id="btn-play" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg shadow-lg transition transform active:scale-95 mb-6 text-lg">
                    게임 시작
                </button>

                <div class="border-t border-gray-200 pt-4">
                    <h3 class="text-lg font-bold text-gray-700 mb-3 flex items-center">
                        <i data-lucide="trophy" class="w-5 h-5 mr-2 text-yellow-500"></i> 명예의 전당
                    </h3>
                    <div class="bg-gray-50 rounded h-48 overflow-y-auto custom-scrollbar p-2">
                        <table class="w-full text-sm">
                            <thead class="text-gray-500 border-b">
                                <tr>
                                    <th class="text-left py-1">순위</th>
                                    <th class="text-left py-1">이름</th>
                                    <th class="text-right py-1">점수</th>
                                </tr>
                            </thead>
                            <tbody id="leaderboard-list">
                                <tr><td colspan="3" class="text-center py-4 text-gray-400">로딩 중...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen" class="hidden absolute inset-0 z-50 bg-black/80 flex items-center justify-center">
            <div class="text-center text-white p-8 animate-float">
                <h1 class="text-6xl font-bold text-yellow-400 mb-4">승리!</h1>
                <p class="text-2xl mb-2">축하합니다!</p>
                <div class="text-xl mb-8 text-gray-300">
                    <p>최종 점수: <span id="final-score" class="text-white font-bold">0</span></p>
                    <p>소요 시간: <span id="final-time" class="text-white font-bold">00:00</span></p>
                </div>
                <button id="btn-victory-home" class="bg-white text-green-800 font-bold py-3 px-8 rounded-full hover:bg-gray-200 transition">
                    메인으로 돌아가기
                </button>
            </div>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="flex-1 p-2 md:p-4 flex flex-col max-w-7xl mx-auto w-full h-full pb- safe-bottom">
            
            <!-- Top Row: Freecells (Left) & Foundations (Right) -->
            <div class="flex justify-between h-[25%] mb-2 shrink-0">
                <!-- Freecells (4) -->
                <div class="flex gap-1.5 w-[48%]">
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-0" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-1" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-2" class="placeholder"></div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="freecell-3" class="placeholder"></div></div>
                </div>

                <!-- Spacer -->
                <div class="w-[4%]"></div>

                <!-- Foundations (4) -->
                <div class="flex gap-1.5 w-[48%]">
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-0" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-1" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-2" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                    <div class="w-[22%] relative h-full flex justify-center"><div id="foundation-3" class="placeholder text-white/20 text-xl font-bold">A</div></div>
                </div>
            </div>

            <!-- Bottom Row: Tableaus (8) -->
            <div class="flex-1 flex gap-1 w-full h-full overflow-hidden relative" id="tableau-area">
                <div id="tableau-0" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-1" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-2" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-3" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-4" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-5" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-6" class="w-[12.5%] relative h-full"></div>
                <div id="tableau-7" class="w-[12.5%] relative h-full"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const userConfig = {
            apiKey: "AIzaSyABtG2uYP6iXpXOphVPTY_roUbHMzBDGek",
            authDomain: "cardgame-8bae4.firebaseapp.com",
            projectId: "cardgame-8bae4",
            storageBucket: "cardgame-8bae4.firebasestorage.app",
            messagingSenderId: "931605513570",
            appId: "1:931605513570:web:8f58953994bda3fdcad83b"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userConfig;
        
        let db, auth, user;

        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            const initAuth = async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            };
            initAuth();

            onAuthStateChanged(auth, (u) => {
                user = u;
                if(user) loadLeaderboard();
            });
        } catch (e) {
            console.error("Firebase init failed:", e);
            document.querySelector("#leaderboard-list").innerHTML = '<tr><td colspan="3" class="text-center py-4">서비스 연결 불가</td></tr>';
        }

        function loadLeaderboard() {
            if (!db) return;
            const colRef = collection(db, 'artifacts', appId, 'public', 'data', 'freecell_scores');
            
            onSnapshot(colRef, (snapshot) => {
                const scores = [];
                snapshot.forEach(doc => scores.push(doc.data()));
                scores.sort((a, b) => b.score - a.score); 
                
                const top10 = scores.slice(0, 10);
                const tbody = document.getElementById('leaderboard-list');
                tbody.innerHTML = '';

                top10.forEach((s, idx) => {
                    const row = `
                        <tr class="border-b border-gray-100 last:border-0 hover:bg-gray-100">
                            <td class="py-2 pl-2 text-gray-500 font-mono">${idx + 1}</td>
                            <td class="py-2 font-medium text-gray-800 truncate max-w-[100px]">${s.nickname}</td>
                            <td class="py-2 text-right pr-2 text-green-700 font-bold">${s.score}</td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                });

                if (scores.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-400">기록이 없습니다.</td></tr>';
                }
            }, (error) => {
                console.error("Leaderboard error:", error);
            });
        }

        async function saveScore(nickname, score, timeStr) {
            if (!db || !user) return;
            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'freecell_scores'), {
                    nickname: nickname,
                    score: score,
                    time: timeStr,
                    uid: user.uid,
                    createdAt: serverTimestamp()
                });
            } catch (e) {
                console.error("Save score failed:", e);
            }
        }
        window.saveGameScore = saveScore;
    </script>

    <script>
        const SUITS = ['♠', '♥', '♣', '♦'];
        const COLORS = { '♠': 'black', '♣': 'black', '♥': 'red', '♦': 'red' };
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        
        let gameState = {
            tableaus: [[], [], [], [], [], [], [], []],
            freecells: [null, null, null, null],
            foundations: [[], [], [], []],
            score: 0,
            startTime: 0,
            timerInterval: null
        };

        let selectedCard = null; 
        let nickname = "";

        // Toast functionality
        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast show';
            toast.innerText = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            document.getElementById('btn-play').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', restartGame);
            document.getElementById('btn-exit').addEventListener('click', exitGame);
            document.getElementById('btn-victory-home').addEventListener('click', exitGame);
            bindGameEvents();
            window.addEventListener('resize', resizeCards);
        });

        function bindGameEvents() {
            for (let i = 0; i < 4; i++) {
                addTouchAndClickHandlers(document.getElementById(`freecell-${i}`), 'freecell', i);
                addTouchAndClickHandlers(document.getElementById(`foundation-${i}`), 'foundation', i);
            }
            for (let i = 0; i < 8; i++) {
                addTouchAndClickHandlers(document.getElementById(`tableau-${i}`), 'tableau', i);
            }
        }

        function addTouchAndClickHandlers(element, type, index) {
            let lastTap = 0;
            let startX, startY;

            element.addEventListener('click', (e) => handlePlaceClick(type, index, e));
            element.addEventListener('dblclick', (e) => handleDoubleClick(type, index));
            
            element.addEventListener('touchstart', (e) => {
                startX = e.changedTouches[0].clientX; // Fixed: Use clientX instead of pageX
                startY = e.changedTouches[0].clientY;
            }, { passive: false });

            element.addEventListener('touchend', (e) => {
                const endX = e.changedTouches[0].clientX; // Fixed: Use clientX
                const endY = e.changedTouches[0].clientY;
                
                if (Math.abs(endX - startX) < 10 && Math.abs(endY - startY) < 10) {
                    e.preventDefault(); // Prevent ghost clicks
                    const currentTime = new Date().getTime();
                    if (currentTime - lastTap < 300) {
                        handleDoubleClick(type, index);
                    } else {
                        handlePlaceClick(type, index, e);
                    }
                    lastTap = currentTime;
                }
            }, { passive: false });
        }

        function resizeCards() { updateUI(); }

        function startGame() {
            const input = document.getElementById('nickname-input');
            const errorMsg = document.getElementById('nickname-error');
            if (!input.value.trim()) {
                errorMsg.classList.remove('hidden');
                input.focus();
                return;
            }
            errorMsg.classList.add('hidden');
            nickname = input.value.trim();
            document.getElementById('user-display').innerText = nickname;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
            initGame();
        }

        function initGame() {
            gameState.tableaus = [[], [], [], [], [], [], [], []];
            gameState.freecells = [null, null, null, null];
            gameState.foundations = [[], [], [], []];
            gameState.score = 0;
            gameState.startTime = Date.now();
            selectedCard = null;

            let deck = [];
            SUITS.forEach(suit => {
                RANKS.forEach((rank, index) => {
                    deck.push({ suit, rank, value: index + 1, color: COLORS[suit], id: `${rank}${suit}` });
                });
            });
            
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }

            deck.forEach((card, i) => {
                gameState.tableaus[i % 8].push(card);
            });

            startTimer();
            updateUI();
        }

        function restartGame() { initGame(); }

        function exitGame() {
            stopTimer();
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
        }

        function createCardHTML(card, isSelected = false) {
            if (!card) return '';
            const suitCode = {'♠':'S', '♥':'H', '♣':'C', '♦':'D'}[card.suit];
            const rankCode = (card.rank === '10') ? '0' : card.rank;
            const imgUrl = `https://deckofcardsapi.com/static/img/${rankCode}${suitCode}.png`;
            const selectedClass = isSelected ? 'selected' : '';
            return `
                <div class="card ${selectedClass}" id="${card.id}">
                    <img src="${imgUrl}" 
                         class="w-full h-full object-cover rounded-sm pointer-events-none select-none" 
                         alt="${card.rank}${card.suit}"
                         onerror="this.style.display='none'; this.parentElement.classList.add('fallback-card');">
                </div>
            `;
        }

        function getTableauOffset(index) { return 20; }

        function updateUI() {
            gameState.freecells.forEach((card, i) => {
                const el = document.getElementById(`freecell-${i}`);
                el.innerHTML = '';
                if (card) {
                    const isSel = selectedCard && selectedCard.type === 'freecell' && selectedCard.index === i;
                    el.innerHTML = createCardHTML(card, isSel);
                }
            });

            gameState.foundations.forEach((pile, i) => {
                const el = document.getElementById(`foundation-${i}`);
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    el.innerHTML = createCardHTML(topCard, false);
                    el.classList.remove('text-white/20', 'text-xl');
                } else {
                    el.innerHTML = 'A';
                    el.classList.add('text-white/20', 'text-xl');
                }
            });

            const offset = getTableauOffset();
            gameState.tableaus.forEach((col, i) => {
                const el = document.getElementById(`tableau-${i}`);
                el.innerHTML = ''; 
                
                col.forEach((card, cardIndex) => {
                    const cardDiv = document.createElement('div');
                    let isSel = false;
                    if (selectedCard && selectedCard.type === 'tableau' && selectedCard.index === i) {
                        if (cardIndex >= selectedCard.originIndex) isSel = true;
                    }
                    
                    cardDiv.innerHTML = createCardHTML(card, isSel);
                    const cardInner = cardDiv.firstElementChild;
                    
                    cardInner.style.top = `${cardIndex * offset}px`; 
                    cardInner.style.zIndex = cardIndex;
                    cardInner.dataset.index = cardIndex; // Store index for specific card clicks
                    
                    el.appendChild(cardInner);
                });
            });

            document.getElementById('score-display').innerText = `점수: ${gameState.score}`;
            checkWin();
        }

        window.handlePlaceClick = (type, index, event) => {
            let cardIndex = -1;
            if (event && (event.type === 'click' || event.type === 'touchend')) {
                let target = event.target;
                if (event.changedTouches) {
                    // Accurately find element under finger
                    target = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
                }
                const cardEl = target ? target.closest('.card') : null;
                if (cardEl && cardEl.dataset.index !== undefined) {
                    cardIndex = parseInt(cardEl.dataset.index);
                }
            }

            if (!selectedCard) {
                selectSource(type, index, cardIndex);
            } 
            else if (selectedCard.type === type && selectedCard.index === index) {
                selectedCard = null;
                updateUI();
            }
            else {
                attemptMove(type, index);
            }
        };

        window.handleDoubleClick = (type, index) => {
            let card = null;
            if (type === 'freecell') {
                card = gameState.freecells[index];
            } else if (type === 'tableau') {
                const col = gameState.tableaus[index];
                if (col.length > 0) card = col[col.length - 1];
            }

            if (!card) return;

            for (let fIdx = 0; fIdx < 4; fIdx++) {
                const pile = gameState.foundations[fIdx];
                let canMove = false;
                
                if (pile.length === 0) {
                    if (card.value === 1) canMove = true;
                } else {
                    const top = pile[pile.length - 1];
                    if (top.suit === card.suit && card.value === top.value + 1) canMove = true;
                }

                if (canMove) {
                    if (type === 'freecell') gameState.freecells[index] = null;
                    else gameState.tableaus[index].pop();
                    
                    pile.push(card);
                    gameState.score += 10;
                    selectedCard = null;
                    updateUI();
                    return; 
                }
            }
        };

        function selectSource(type, index, clickedIndex = -1) {
            if (type === 'freecell') {
                const card = gameState.freecells[index];
                if (card) selectedCard = { type, index, cards: [card], originIndex: 0 };
            } else if (type === 'tableau') {
                const col = gameState.tableaus[index];
                if (col.length > 0) {
                    // Logic: Find the longest valid stack at the bottom
                    let validStartIdx = col.length - 1;
                    for (let i = col.length - 2; i >= 0; i--) {
                        const current = col[i];
                        const next = col[i+1];
                        const isDiffColor = current.color !== next.color;
                        const isRankAbove = current.value === next.value + 1;
                        if (isDiffColor && isRankAbove) {
                            validStartIdx = i;
                        } else {
                            break; 
                        }
                    }

                    // Determine Selection Start
                    let selectFrom = validStartIdx;
                    
                    if (clickedIndex !== -1) {
                        if (clickedIndex >= validStartIdx) {
                            selectFrom = clickedIndex; // Allow selecting sub-stack
                        } 
                        // If clicked invalid area, default to longest valid stack
                    }

                    const stack = col.slice(selectFrom);
                    selectedCard = { type, index, cards: stack, originIndex: selectFrom };
                }
            }
            if (selectedCard) updateUI();
        }

        function getAvailableMoves() {
            const emptyFreecells = gameState.freecells.filter(c => c === null).length;
            const emptyTableaus = gameState.tableaus.filter(c => c.length === 0).length;
            return { emptyFreecells, emptyTableaus };
        }

        function attemptMove(destType, destIndex) {
            if (!selectedCard) return;

            let success = false;
            let movePoints = 0;
            const movingCards = selectedCard.cards;
            
            if (destType === 'freecell') {
                if (movingCards.length === 1 && gameState.freecells[destIndex] === null) {
                    removeFromSource(1);
                    gameState.freecells[destIndex] = movingCards[0];
                    success = true;
                }
            } 
            else if (destType === 'foundation') {
                if (movingCards.length === 1) {
                    const card = movingCards[0];
                    const pile = gameState.foundations[destIndex];
                    if (pile.length === 0) {
                        if (card.value === 1) { 
                            removeFromSource(1);
                            pile.push(card);
                            success = true;
                            movePoints = 10;
                        }
                    } else {
                        const top = pile[pile.length - 1];
                        if (top.suit === card.suit && card.value === top.value + 1) {
                            removeFromSource(1);
                            pile.push(card);
                            success = true;
                            movePoints = 10;
                        }
                    }
                }
            } 
            else if (destType === 'tableau') {
                const col = gameState.tableaus[destIndex];
                const { emptyFreecells, emptyTableaus } = getAvailableMoves();
                
                let effectiveEmptyCols = emptyTableaus;
                if (col.length === 0) effectiveEmptyCols = Math.max(0, emptyTableaus - 1);
                
                const maxCards = (emptyFreecells + 1) * Math.pow(2, effectiveEmptyCols);

                if (movingCards.length <= maxCards) {
                    if (col.length === 0) {
                        removeFromSource(movingCards.length);
                        movingCards.forEach(c => col.push(c));
                        success = true;
                    } else {
                        const destCard = col[col.length - 1];
                        const bottomMoving = movingCards[0]; 
                        
                        if (bottomMoving.color !== destCard.color && bottomMoving.value === destCard.value - 1) {
                            removeFromSource(movingCards.length);
                            movingCards.forEach(c => col.push(c));
                            success = true;
                        }
                    }
                } else {
                    showToast(`이동 가능한 카드 수(${maxCards}장)를 초과했습니다.`);
                }
            }

            if (success) {
                gameState.score += movePoints;
                selectedCard = null;
                updateUI();
            } else {
                selectedCard = null;
                updateUI();
            }
        }

        function removeFromSource(count) {
            if (selectedCard.type === 'freecell') {
                gameState.freecells[selectedCard.index] = null;
            } else if (selectedCard.type === 'tableau') {
                for(let i=0; i<count; i++) {
                    gameState.tableaus[selectedCard.index].pop();
                }
            }
        }

        function checkWin() {
            const total = gameState.foundations.reduce((acc, pile) => acc + pile.length, 0);
            if (total === 52) endGame();
        }

        function endGame() {
            stopTimer();
            const timeStr = document.getElementById('timer-display').innerText.replace('시간: ', '');
            document.getElementById('final-score').innerText = gameState.score;
            document.getElementById('final-time').innerText = timeStr;
            document.getElementById('victory-screen').classList.remove('hidden');
            
            if (window.saveGameScore && nickname) {
                window.saveGameScore(nickname, gameState.score, timeStr);
            }
        }

        function startTimer() {
            stopTimer();
            const start = Date.now();
            gameState.timerInterval = setInterval(() => {
                const delta = Math.floor((Date.now() - start) / 1000);
                const m = Math.floor(delta / 60).toString().padStart(2, '0');
                const s = (delta % 60).toString().padStart(2, '0');
                document.getElementById('timer-display').innerText = `시간: ${m}:${s}`;
            }, 1000);
        }

        function stopTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        }
    </script>
</body>
</html>